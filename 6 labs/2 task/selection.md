# Pattern Selection for Lab 6.2

## SCENARIO_01 – App-Wide Configuration Store

- Problem Summary: В приложении много модулей, и всем нужен единый источник конфигурации; сейчас значения дублируются в нескольких файлах, из‑за чего изменения легко пропустить.
- Selected Pattern Family: Creational
- Selected Specific Pattern: Singleton
- Why This Family? По определению из Ch. 6, creational‑паттерны нужны, когда базовый способ создания объектов добавляет сложность и нужно контролировать сам процесс создания. Здесь ключевое требование — «должен существовать ровно один конфигурационный объект и все модули должны его переиспользовать».
- Why This Pattern? Singleton, согласно Ch. 6 и GoF таблице, — это класс, у которого есть только один экземпляр и глобальная точка доступа к нему. Конструкция `AppConfig.getInstance()` естественно реализует этот подход: при первом вызове создаётся объект, все последующие получают тот же экземпляр, а настройки живут, пока работает приложение.
- Alternative Considered: Можно было бы использовать Abstract Factory, чтобы создавать разные наборы настроек для разных окружений, но это не решает требование единственности экземпляра внутри приложения и не даёт глобальной точки доступа.

---

## SCENARIO_02 – Legacy Payment Gateway Adapter

- Problem Summary: Есть старый банковский шлюз с неудобным интерфейсом, а новый checkout‑код ожидает современный интерфейс с объектом `{ amount, currency, cardToken }`; нужно их «подружить», не переписывая старый код.
- Selected Pattern Family: Structural
- Selected Specific Pattern: Adapter
- Why This Family? Structural‑паттерны из Ch. 6 отвечают за то, как объекты связываются и компонуются, чтобы работать вместе, даже если исходно не совместимы. В тексте прямо говорится о необходимости «match interfaces» между новыми и legacy компонентами.
- Why This Pattern? Adapter в GoF таблице определяется как паттерн, который согласует интерфейсы разных классов, чтобы они могли работать вместе при несовместимых сигнатурах. Класс `PaymentAdapter` как раз получает ссылку на старый `LegacyBankGateway` и предоставляет ожидаемый современным кодом метод `charge`, переводя параметры во внутренний вызов `processPayment`.
- Alternative Considered: Facade также мог бы скрыть сложность старого API, но он не решает проблему несовместимой сигнатуры; основная цель здесь — именно адаптация интерфейса, а не агрегирование нескольких подсистем.

---

## SCENARIO_03 – UI Notification System

- Problem Summary: Несколько независимых компонентов (GradeBook, Calendar и др.) должны реагировать на событие «домашка отправлена», причём список слушателей может меняться динамически.
- Selected Pattern Family: Behavioral
- Selected Specific Pattern: Observer
- Why This Family? Поведенческие паттерны, по Ch. 6, фокусируются на коммуникации между объектами и распределении ответственности. Здесь задача — организовать оповещение многих получателей о событии в одном месте, не связывая отправителя с конкретными реализациями.
- Why This Pattern? Observer в GoF‑таблице определяется как способ уведомлять множество классов об изменении, чтобы поддерживать согласованность. Класс `HomeworkReminder` выполняет роль субъекта: он даёт `subscribe`/`unsubscribe`, хранит список подписчиков и вызывает у них `update(homework)` при `submit`, реализуя классическую схему наблюдателя.
- Alternative Considered: Mediator тоже централизует взаимодействие, но он координирует двустороннюю коммуникацию между несколькими коллегами. Здесь же достаточно однонаправленного уведомления «субъект → наблюдатели», что делает Observer проще и точнее.

---

## SCENARIO_04 – Report Builder

- Problem Summary: Нужно строить отчёты разных форматов (HTML, PDF, потом CSV) с одинаковыми шагами построения, так чтобы добавление нового формата не требовало менять общую логику построения.
- Selected Pattern Family: Creational
- Selected Specific Pattern: Builder
- Why This Family? В Ch. 6 Builder описан как порождающий паттерн, который отделяет процесс конструирования объекта от его представления, при этом последовательность шагов остаётся неизменной. В сценарии прямо сказано, что процесс (steps) один и тот же, но выходные представления разные.
- Why This Pattern? Builder из GoF таблицы «separates object construction from its representation; always creates the same type of object». Здесь `ReportDirector` управляет высокоуровневой последовательностью `reset`, `addHeader`, `addBody`, `addFooter`, а конкретные builder‑классы (`HTMLReportBuilder` и будущий `PDFReportBuilder`) реализуют детали форматирования.
- Alternative Considered: Template Method мог бы зафиксировать алгоритм в базовом классе и дать подклассам реализовать шаги, но в JavaScript‑контексте с отдельным директором и независимыми строителями Builder лучше отделяет конструктор от представления и позволяет переиспользовать один и тот же Director с разными builders.

---

## SCENARIO_05 – Undo/Redo for Task Manager

- Problem Summary: Kanban‑доска должна поддерживать undo/redo для разных действий (перемещение, переименование, удаление), при этом добавление новых типов действий не должно ломать историю.
- Selected Pattern Family: Behavioral
- Selected Specific Pattern: Command
- Why This Family? С точки зрения Ch. 6, это поведенческая задача: нужно организовать выполнение и отмену действий, абстрагируя «что делается» от «кто инициирует». Объекты должны коммуницировать через единый протокол undo/redo.
- Why This Pattern? Command в GoF‑таблице — это паттерн, который «separates the execution of a command from its invoker» и инкапсулирует действие в отдельный объект. Здесь каждая операция, например `MoveCardCommand` или `RenameCardCommand`, реализует `execute` и `undo`, а `ActionHistory` лишь хранит и вызывает команды, оставаясь неизменным при добавлении новых типов действий.
- Alternative Considered: Можно было бы использовать Memento для сохранения снимков состояния доски, но тогда придётся хранить тяжёлые копии структуры. Command точечно описывает каждое действие и его обратную операцию, что лучше соответствует требованиям.

---

## SCENARIO_06 – Large-Scale Particle System

- Problem Summary: Игра должна отображать десятки тысяч частиц, у которых совпадают типовые данные (форма, цвет, текстура), но различаются координаты и размер; наивная реализация расходует слишком много памяти.
- Selected Pattern Family: Structural
- Selected Specific Pattern: Flyweight
- Why This Family? Structural‑паттерны из Ch. 6 описывают, как организовать связи и внутреннюю структуру объектов для эффективности. В сценарии требуется разделить общий тип (shape/color/texture) и уникальные данные (x, y, size), чтобы уменьшить объём памяти.
- Why This Pattern? В GoF‑таблице Flyweight определён как «fine‑grained instance used for efficient sharing of information that is contained elsewhere». Здесь `ParticleType` хранит intrinsic‑состояние, а `ParticleTypeCache` раздаёт общие экземпляры, тогда как `Particle` хранит только extrinsic‑состояние и ссылку на `type`, полностью следуя идее flyweight.
- Alternative Considered: Можно было бы использовать Prototype для клонирования «частицы‑шаблона», но это всё равно создавало бы много копий одних и тех же типовых данных. Flyweight позволяет реально шарить общие объекты и резко снижает использование памяти.
